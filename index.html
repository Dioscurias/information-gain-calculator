<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Information Gain Calculator & Decision Tree Builder</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: #0f172a;
    color: #e2e8f0;
    min-height: 100vh;
    line-height: 1.6;
  }

  header {
    background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
    border-bottom: 1px solid #334155;
    padding: 1.5rem 2rem;
    text-align: center;
  }

  header h1 {
    font-size: 1.75rem;
    font-weight: 700;
    background: linear-gradient(135deg, #38bdf8, #818cf8);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  header p { color: #94a3b8; font-size: 0.9rem; margin-top: 0.25rem; }


  .container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 1.5rem;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
  }

  .full-width { grid-column: 1 / -1; }

  .card {
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 12px;
    padding: 1.25rem;
    overflow: hidden;
  }

  .card h2 {
    font-size: 1.1rem;
    margin-bottom: 1rem;
    color: #f1f5f9;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .card h2 .icon {
    width: 28px; height: 28px;
    border-radius: 6px;
    display: flex; align-items: center; justify-content: center;
    font-size: 0.85rem;
  }

  .btn-row { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem; }

  button {
    padding: 0.5rem 1rem;
    border: 1px solid #475569;
    border-radius: 8px;
    background: #334155;
    color: #e2e8f0;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.15s;
  }

  button:hover { background: #475569; border-color: #64748b; }

  .btn-primary {
    background: linear-gradient(135deg, #3b82f6, #6366f1);
    border: none;
    color: #fff;
    font-weight: 600;
    padding: 0.6rem 1.5rem;
    font-size: 0.95rem;
  }

  .btn-primary:hover { opacity: 0.9; }

  .btn-danger { border-color: #ef4444; color: #f87171; }
  .btn-danger:hover { background: #7f1d1d; }

  /* Data Table */
  .table-wrap { overflow-x: auto; max-height: 400px; overflow-y: auto; }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.85rem;
  }

  th, td {
    padding: 0.5rem 0.75rem;
    border: 1px solid #334155;
    text-align: left;
    white-space: nowrap;
  }

  th {
    background: #0f172a;
    position: sticky;
    top: 0;
    z-index: 1;
    font-weight: 600;
  }

  th.target-col { color: #f59e0b; }

  td { background: #1e293b; }

  th input, td input {
    background: transparent;
    border: none;
    color: inherit;
    width: 100%;
    min-width: 60px;
    font-size: 0.85rem;
    outline: none;
    padding: 2px;
  }

  th input { font-weight: 600; }
  th input::placeholder, td input::placeholder { color: #475569; }

  td input:focus { background: #0f172a; border-radius: 3px; }

  tr:hover td { background: #263348; }

  .row-num {
    color: #475569;
    font-size: 0.75rem;
    text-align: center;
    width: 30px;
    padding: 0.5rem 0.4rem;
    user-select: none;
  }

  .del-row-btn {
    background: none; border: none; color: #64748b;
    cursor: pointer; font-size: 0.75rem; padding: 2px 6px; border-radius: 4px;
  }
  .del-row-btn:hover { color: #f87171; background: #7f1d1d44; }

  /* Results */
  .result-section { margin-bottom: 1.25rem; }
  .result-section h3 {
    font-size: 0.95rem;
    color: #94a3b8;
    margin-bottom: 0.5rem;
    border-bottom: 1px solid #334155;
    padding-bottom: 0.35rem;
  }

  .entropy-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: #38bdf8;
  }

  .gain-bar-wrap { margin-bottom: 0.6rem; }

  .gain-label {
    display: flex;
    justify-content: space-between;
    font-size: 0.85rem;
    margin-bottom: 0.2rem;
  }

  .gain-label .attr-name { font-weight: 600; color: #e2e8f0; }
  .gain-label .attr-val { color: #38bdf8; font-family: 'Courier New', monospace; }

  .gain-bar-bg {
    height: 22px;
    background: #0f172a;
    border-radius: 6px;
    overflow: hidden;
  }

  .gain-bar-fill {
    height: 100%;
    border-radius: 6px;
    transition: width 0.5s ease;
    min-width: 2px;
  }

  /* Explanation */
  .math-steps {
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    color: #94a3b8;
    background: #0f172a;
    border-radius: 8px;
    padding: 1rem;
    max-height: 500px;
    overflow-y: auto;
    line-height: 1.8;
    white-space: pre-wrap;
  }

  .math-steps .highlight { color: #38bdf8; font-weight: 600; }
  .math-steps .formula { color: #a78bfa; }
  .math-steps .section-title { color: #f59e0b; font-weight: 700; font-size: 0.9rem; }

  /* Tree */
  .tree-container {
    overflow: auto;
    background: #0f172a;
    border-radius: 8px;
    min-height: 300px;
    position: relative;
  }

  .tree-container svg { display: block; }

  .tree-node rect {
    rx: 8; ry: 8;
    stroke-width: 2;
  }

  .tree-node text {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 12px;
    fill: #e2e8f0;
    text-anchor: middle;
    dominant-baseline: middle;
  }

  .tree-edge {
    stroke: #475569;
    stroke-width: 2;
    fill: none;
  }

  .edge-label {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 11px;
    fill: #94a3b8;
    text-anchor: middle;
  }

  .no-data {
    text-align: center;
    color: #475569;
    padding: 3rem 1rem;
    font-size: 0.95rem;
  }

  @media (max-width: 900px) {
    .container { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<header>
  <h1>Information Gain Calculator</h1>
  <p>Build decision trees with step-by-step entropy calculations</p>
</header>
<!-- TAG: IC | XC ; NI | KA -->

<div class="container">

  <!-- Dataset Input -->
  <div class="card full-width">
    <h2><span class="icon" style="background:#3b82f622;color:#3b82f6;">T</span> Dataset</h2>
    <div class="btn-row">
      <button onclick="loadSampleData()" class="btn-primary">Load Sample Data</button>
      <button onclick="addColumn()">+ Column</button>
      <button onclick="addRow()">+ Row</button>
      <button onclick="removeLastColumn()" class="btn-danger">- Column</button>
      <button onclick="clearData()" class="btn-danger">Clear</button>
      <span style="flex:1"></span>
      <button onclick="calculate()" class="btn-primary" id="calcBtn">Calculate Information Gain</button>
    </div>
    <div class="table-wrap">
      <table id="dataTable"><thead><tr></tr></thead><tbody></tbody></table>
    </div>
    <p style="color:#64748b;font-size:0.78rem;margin-top:0.5rem;">
      The <strong style="color:#f59e0b;">last column</strong> is treated as the target/label. Edit headers to name attributes.
      Tip: copy cells in Excel and paste into any table cell.
    </p>
  </div>

  <!-- Information Gain Results -->
  <div class="card">
    <h2><span class="icon" style="background:#10b98122;color:#10b981;">G</span> Information Gain</h2>
    <div id="resultsPanel">
      <div class="no-data">Enter data and click <strong>Calculate</strong> to see results.</div>
    </div>
  </div>

  <!-- Step-by-step Explanation -->
  <div class="card">
    <h2><span class="icon" style="background:#a78bfa22;color:#a78bfa;">E</span> Step-by-Step Explanation</h2>
    <div id="explanationPanel">
      <div class="no-data">Calculation steps will appear here.</div>
    </div>
  </div>

  <!-- Decision Tree -->
  <div class="card full-width">
    <h2><span class="icon" style="background:#f59e0b22;color:#f59e0b;">D</span> Decision Tree</h2>
    <div class="tree-container" id="treeContainer">
      <div class="no-data">The decision tree will be visualized here after calculation.</div>
    </div>
  </div>

</div>

<script>
// ---- State ----
let columns = [];
let rows = [];

// ---- Table Rendering ----
function renderTable() {
  const thead = document.querySelector('#dataTable thead tr');
  const tbody = document.querySelector('#dataTable tbody');
  thead.innerHTML = '';
  tbody.innerHTML = '';

  // Row number header
  const thNum = document.createElement('th');
  thNum.className = 'row-num';
  thNum.textContent = '#';
  thead.appendChild(thNum);

  columns.forEach((col, ci) => {
    const th = document.createElement('th');
    if (ci === columns.length - 1) th.className = 'target-col';
    const inp = document.createElement('input');
    inp.value = col;
    inp.placeholder = ci === columns.length - 1 ? 'Target' : `Attr ${ci + 1}`;
    inp.addEventListener('input', () => { columns[ci] = inp.value; });
    th.appendChild(inp);
    thead.appendChild(th);
  });

  // Delete header
  const thDel = document.createElement('th');
  thDel.style.width = '30px';
  thead.appendChild(thDel);

  rows.forEach((row, ri) => {
    const tr = document.createElement('tr');
    const tdNum = document.createElement('td');
    tdNum.className = 'row-num';
    tdNum.textContent = ri + 1;
    tr.appendChild(tdNum);

    columns.forEach((_, ci) => {
      const td = document.createElement('td');
      const inp = document.createElement('input');
      inp.value = row[ci] || '';
      inp.addEventListener('input', () => { rows[ri][ci] = inp.value.trim(); });
      inp.addEventListener('paste', (e) => handleCellPaste(e, ri, ci));
      td.appendChild(inp);
      tr.appendChild(td);
    });

    const tdDel = document.createElement('td');
    tdDel.style.padding = '0';
    const delBtn = document.createElement('button');
    delBtn.className = 'del-row-btn';
    delBtn.textContent = '\u00d7';
    delBtn.title = 'Delete row';
    delBtn.addEventListener('click', () => { rows.splice(ri, 1); renderTable(); });
    tdDel.appendChild(delBtn);
    tr.appendChild(tdDel);

    tbody.appendChild(tr);
  });
}

function parsePastedMatrix(text) {
  const normalized = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n+$/g, '');
  if (!normalized) return [];
  return normalized
    .split('\n')
    .map(line => line.split('\t').map(cell => cell.trim()));
}

function ensureShape(requiredRows, requiredCols) {
  if (requiredCols > columns.length) {
    while (columns.length < requiredCols) {
      const insertAt = Math.max(columns.length - 1, 0);
      const attrName = `Attr ${insertAt + 1}`;
      columns.splice(insertAt, 0, attrName);
      rows.forEach(r => r.splice(insertAt, 0, ''));
    }
  }

  rows.forEach(r => {
    while (r.length < columns.length) r.push('');
  });

  while (rows.length < requiredRows) {
    rows.push(new Array(columns.length).fill(''));
  }
}

function handleCellPaste(event, startRow, startCol) {
  const raw = event.clipboardData && event.clipboardData.getData('text');
  if (!raw) return;

  if (!raw.includes('\t') && !raw.includes('\n') && !raw.includes('\r')) return;
  event.preventDefault();

  const matrix = parsePastedMatrix(raw);
  if (matrix.length === 0) return;

  const maxCols = Math.max(...matrix.map(r => r.length), 0);
  if (maxCols === 0) return;

  ensureShape(startRow + matrix.length, startCol + maxCols);
  matrix.forEach((r, ri) => {
    r.forEach((val, ci) => {
      rows[startRow + ri][startCol + ci] = val;
    });
  });
  renderTable();
}

function addColumn() {
  columns.push('');
  rows.forEach(r => r.push(''));
  renderTable();
}

function addRow() {
  rows.push(new Array(columns.length).fill(''));
  renderTable();
}

function removeLastColumn() {
  if (columns.length <= 1) return;
  columns.pop();
  rows.forEach(r => r.pop());
  renderTable();
}

function clearData() {
  columns = ['Attr 1', 'Target'];
  rows = [['', '']];
  renderTable();
  document.getElementById('resultsPanel').innerHTML = '<div class="no-data">Enter data and click <strong>Calculate</strong> to see results.</div>';
  document.getElementById('explanationPanel').innerHTML = '<div class="no-data">Calculation steps will appear here.</div>';
  document.getElementById('treeContainer').innerHTML = '<div class="no-data">The decision tree will be visualized here after calculation.</div>';
}

function loadSampleData() {
  columns = ['Outlook', 'Temperature', 'Humidity', 'Wind', 'Play Tennis'];
  rows = [
    ['Sunny','Hot','High','Weak','No'],
    ['Sunny','Hot','High','Strong','No'],
    ['Overcast','Hot','High','Weak','Yes'],
    ['Rain','Mild','High','Weak','Yes'],
    ['Rain','Cool','Normal','Weak','Yes'],
    ['Rain','Cool','Normal','Strong','No'],
    ['Overcast','Cool','Normal','Strong','Yes'],
    ['Sunny','Mild','High','Weak','No'],
    ['Sunny','Cool','Normal','Weak','Yes'],
    ['Rain','Mild','Normal','Weak','Yes'],
    ['Sunny','Mild','Normal','Strong','Yes'],
    ['Overcast','Mild','High','Strong','Yes'],
    ['Overcast','Hot','Normal','Weak','Yes'],
    ['Rain','Mild','High','Strong','No'],
  ];
  renderTable();
}

// ---- Math helpers ----
function log2(x) { return x === 0 ? 0 : Math.log2(x); }

function entropy(counts) {
  const total = counts.reduce((a, b) => a + b, 0);
  if (total === 0) return 0;
  let h = 0;
  for (const c of counts) {
    const p = c / total;
    h -= p * log2(p);
  }
  return h;
}

function countValues(arr) {
  const map = {};
  arr.forEach(v => { map[v] = (map[v] || 0) + 1; });
  return map;
}

// ---- Calculation ----
function calculate() {
  // Parse data
  const nCols = columns.length;
  if (nCols < 2) { alert('Need at least one attribute and one target column.'); return; }

  const validRows = rows.filter(r => r.length === nCols && r.every(v => v !== ''));
  if (validRows.length === 0) { alert('No complete rows found. Fill in the table first.'); return; }

  const targetIdx = nCols - 1;
  const targetValues = validRows.map(r => r[targetIdx]);
  const targetCounts = countValues(targetValues);
  const totalEntropy = entropy(Object.values(targetCounts));

  const attrIndices = [];
  for (let i = 0; i < targetIdx; i++) attrIndices.push(i);

  const gains = [];
  let explanation = '';

  // Overall entropy
  explanation += `<span class="section-title">OVERALL ENTROPY (${columns[targetIdx]})</span>\n`;
  explanation += `Total samples: ${validRows.length}\n`;
  for (const [val, cnt] of Object.entries(targetCounts)) {
    explanation += `  ${val}: ${cnt} (${(cnt / validRows.length * 100).toFixed(1)}%)\n`;
  }
  explanation += `\n<span class="formula">H(S) = `;
  const parts = [];
  for (const [val, cnt] of Object.entries(targetCounts)) {
    const p = cnt / validRows.length;
    parts.push(`-(${cnt}/${validRows.length}) * log2(${cnt}/${validRows.length})`);
  }
  explanation += parts.join('\n       ');
  explanation += `</span>\n<span class="highlight">H(S) = ${totalEntropy.toFixed(4)}</span>\n\n`;

  // Per attribute
  for (const ai of attrIndices) {
    const attrName = columns[ai] || `Attr ${ai + 1}`;
    const attrValues = validRows.map(r => r[ai]);
    const uniqueVals = [...new Set(attrValues)];

    explanation += `<span class="section-title">ATTRIBUTE: ${attrName}</span>\n`;

    let condEntropy = 0;
    const subsets = {};

    for (const val of uniqueVals) {
      const subset = validRows.filter(r => r[ai] === val);
      const subTargetCounts = countValues(subset.map(r => r[targetIdx]));
      const subH = entropy(Object.values(subTargetCounts));
      const weight = subset.length / validRows.length;
      condEntropy += weight * subH;

      subsets[val] = { count: subset.length, targetCounts: subTargetCounts, entropy: subH, weight };

      explanation += `  ${attrName} = "${val}" (${subset.length}/${validRows.length}):\n`;
      for (const [tv, tc] of Object.entries(subTargetCounts)) {
        explanation += `    ${tv}: ${tc}\n`;
      }
      explanation += `    <span class="formula">H = ${subH.toFixed(4)}</span>\n`;
    }

    explanation += `\n  <span class="formula">H(S|${attrName}) = `;
    const cParts = uniqueVals.map(v => `(${subsets[v].count}/${validRows.length}) * ${subsets[v].entropy.toFixed(4)}`);
    explanation += cParts.join(' + ');
    explanation += ` = ${condEntropy.toFixed(4)}</span>\n`;

    const gain = totalEntropy - condEntropy;
    explanation += `  <span class="highlight">Gain(${attrName}) = ${totalEntropy.toFixed(4)} - ${condEntropy.toFixed(4)} = ${gain.toFixed(4)}</span>\n\n`;

    gains.push({ name: attrName, index: ai, gain, condEntropy });
  }

  gains.sort((a, b) => b.gain - a.gain);

  // Render results panel
  const maxGain = Math.max(...gains.map(g => g.gain), 0.001);
  const colors = ['#38bdf8', '#818cf8', '#a78bfa', '#f472b6', '#34d399', '#fbbf24', '#fb923c'];

  let html = `<div class="result-section"><h3>Dataset Entropy</h3><div class="entropy-value">${totalEntropy.toFixed(4)}</div><p style="color:#64748b;font-size:0.8rem;margin-top:0.25rem;">${validRows.length} samples, ${Object.keys(targetCounts).length} classes</p></div>`;
  html += `<div class="result-section"><h3>Information Gain by Attribute</h3>`;

  gains.forEach((g, i) => {
    const pct = (g.gain / maxGain) * 100;
    const color = colors[i % colors.length];
    html += `<div class="gain-bar-wrap">
      <div class="gain-label"><span class="attr-name">${g.name}</span><span class="attr-val">${g.gain.toFixed(4)}</span></div>
      <div class="gain-bar-bg"><div class="gain-bar-fill" style="width:${pct}%;background:${color};"></div></div>
    </div>`;
  });

  html += `</div>`;
  document.getElementById('resultsPanel').innerHTML = html;

  // Render explanation
  document.getElementById('explanationPanel').innerHTML = `<div class="math-steps">${explanation}</div>`;

  // Build and render tree
  const tree = buildID3(validRows, attrIndices.slice(), targetIdx);
  renderTree(tree);
}

// ---- ID3 ----
function buildID3(data, availableAttrs, targetIdx) {
  const targets = data.map(r => r[targetIdx]);
  const unique = [...new Set(targets)];

  // Pure node
  if (unique.length === 1) {
    return { type: 'leaf', label: unique[0], count: data.length };
  }

  // No attributes left â€” majority vote
  if (availableAttrs.length === 0) {
    const tc = countValues(targets);
    const majority = Object.entries(tc).sort((a, b) => b[1] - a[1])[0][0];
    return { type: 'leaf', label: majority, count: data.length };
  }

  // Find best attribute
  const totalH = entropy(Object.values(countValues(targets)));
  let bestAttr = availableAttrs[0];
  let bestGain = -1;

  for (const ai of availableAttrs) {
    const vals = [...new Set(data.map(r => r[ai]))];
    let condH = 0;
    for (const v of vals) {
      const subset = data.filter(r => r[ai] === v);
      condH += (subset.length / data.length) * entropy(Object.values(countValues(subset.map(r => r[targetIdx]))));
    }
    const g = totalH - condH;
    if (g > bestGain) { bestGain = g; bestAttr = ai; }
  }

  const node = {
    type: 'node',
    attribute: columns[bestAttr] || `Attr ${bestAttr + 1}`,
    attrIndex: bestAttr,
    gain: bestGain,
    children: [],
    count: data.length
  };

  const vals = [...new Set(data.map(r => r[bestAttr]))];
  const remaining = availableAttrs.filter(a => a !== bestAttr);

  for (const v of vals) {
    const subset = data.filter(r => r[bestAttr] === v);
    const edgeRatio = subset.length / data.length;
    if (subset.length === 0) {
      const tc = countValues(targets);
      const majority = Object.entries(tc).sort((a, b) => b[1] - a[1])[0][0];
      node.children.push({
        edgeLabel: v,
        edgeCount: 0,
        edgeRatio,
        child: { type: 'leaf', label: majority, count: 0 }
      });
    } else {
      node.children.push({
        edgeLabel: v,
        edgeCount: subset.length,
        edgeRatio,
        child: buildID3(subset, remaining, targetIdx)
      });
    }
  }

  return node;
}

// ---- Tree Rendering (SVG) ----
function renderTree(tree) {
  const container = document.getElementById('treeContainer');
  const layout = layoutTree(tree, 0, 0);
  const { minX, maxX, minY, maxY } = getBounds(layout);
  const totalCount = tree.count || 1;

  const padding = 40;
  const width = (maxX - minX) + padding * 2;
  const height = (maxY - minY) + padding * 2;
  const offsetX = -minX + padding;
  const offsetY = -minY + padding;

  let svg = `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">`;
  svg += renderEdges(layout, offsetX, offsetY);
  svg += renderNodes(layout, offsetX, offsetY, undefined, totalCount);
  svg += `</svg>`;
  container.innerHTML = svg;
}

const NODE_W = 130;
const NODE_H = 52;
const LEAF_W = 100;
const LEAF_H = 46;
const H_GAP = 44;
const V_GAP = 90;

function layoutTree(node, depth, index) {
  if (node.type === 'leaf') {
    return { node, x: 0, y: depth * (NODE_H + V_GAP), width: LEAF_W, children: [] };
  }

  const childLayouts = node.children.map((c, i) => {
    const cl = layoutTree(c.child, depth + 1, i);
    cl.edgeLabel = c.edgeLabel;
    cl.edgeRatio = c.edgeRatio;
    return cl;
  });

  const totalChildWidth = childLayouts.reduce((s, c) => s + c.width, 0) + H_GAP * (childLayouts.length - 1);
  const nodeWidth = Math.max(NODE_W, totalChildWidth);

  let cx = -totalChildWidth / 2;
  for (const cl of childLayouts) {
    cl.x = cx + cl.width / 2;
    cx += cl.width + H_GAP;
  }

  return {
    node,
    x: 0,
    y: depth * (NODE_H + V_GAP),
    width: nodeWidth,
    children: childLayouts
  };
}

function getBounds(layout) {
  const selfW = layout.node.type === 'leaf' ? LEAF_W : NODE_W;
  const selfH = layout.node.type === 'leaf' ? LEAF_H : NODE_H;
  let minX = layout.x - selfW / 2;
  let maxX = layout.x + selfW / 2;
  let minY = layout.y - selfH / 2;
  let maxY = layout.y + selfH / 2;
  for (const c of layout.children) {
    const b = getBoundsOffset(c, layout.x);
    minX = Math.min(minX, b.minX);
    maxX = Math.max(maxX, b.maxX);
    minY = Math.min(minY, b.minY);
    maxY = Math.max(maxY, b.maxY);
  }
  return { minX, maxX, minY, maxY };
}

function getBoundsOffset(layout, parentX) {
  const absX = parentX + layout.x;
  const w = layout.node.type === 'leaf' ? LEAF_W : NODE_W;
  const h = layout.node.type === 'leaf' ? LEAF_H : NODE_H;
  let minX = absX - w / 2;
  let maxX = absX + w / 2;
  let minY = layout.y - h / 2;
  let maxY = layout.y + h / 2;
  for (const c of layout.children) {
    const b = getBoundsOffset(c, absX);
    minX = Math.min(minX, b.minX);
    maxX = Math.max(maxX, b.maxX);
    minY = Math.min(minY, b.minY);
    maxY = Math.max(maxY, b.maxY);
  }
  return { minX, maxX, minY, maxY };
}

function renderEdges(layout, offX, offY, parentAbsX) {
  let svg = '';
  const absX = (parentAbsX !== undefined ? parentAbsX : 0) + layout.x + offX;
  const absY = layout.y + offY;

  const siblings = layout.children.length;
  for (let i = 0; i < siblings; i++) {
    const c = layout.children[i];
    const cAbsX = absX + c.x;
    const cAbsY = c.y + offY;
    const midY = (absY + NODE_H + cAbsY) / 2;
    svg += `<path class="tree-edge" d="M${absX},${absY + NODE_H / 2} C${absX},${midY} ${cAbsX},${midY} ${cAbsX},${cAbsY - (c.node.type === 'leaf' ? LEAF_H : NODE_H) / 2}"/>`;
    // Place labels closer to child branches to reduce overlap on multi-way splits.
    const childTop = cAbsY - (c.node.type === 'leaf' ? LEAF_H : NODE_H) / 2;
    const lx = absX + (cAbsX - absX) * 0.7;
    const stagger = (i - (siblings - 1) / 2) * 10;
    const ly = childTop - 14 + stagger;
    const edgePct = ((c.edgeRatio || 0) * 100).toFixed(1);
    const edgeText = `${c.edgeLabel} (${edgePct}%)`;
    const boxW = Math.max(58, Math.min(140, edgeText.length * 6.1 + 14));
    svg += `<rect x="${lx - boxW / 2}" y="${ly - 10}" width="${boxW}" height="20" rx="6" fill="#1e293b" stroke="#334155" stroke-width="1"/>`;
    svg += `<text class="edge-label" x="${lx}" y="${ly + 3}">${escHTML(edgeText)}</text>`;
    svg += renderEdges(c, offX, offY, absX);
  }
  return svg;
}

function renderNodes(layout, offX, offY, parentAbsX, totalCount) {
  let svg = '';
  const absX = (parentAbsX !== undefined ? parentAbsX : 0) + layout.x + offX;
  const absY = layout.y + offY;
  const nodeCount = layout.node.count || 0;
  const nodePct = totalCount > 0 ? ((nodeCount / totalCount) * 100).toFixed(1) : '0.0';

  if (layout.node.type === 'leaf') {
    svg += `<g class="tree-node">`;
    svg += `<rect x="${absX - LEAF_W / 2}" y="${absY - LEAF_H / 2}" width="${LEAF_W}" height="${LEAF_H}" fill="#064e3b" stroke="#10b981"/>`;
    svg += `<text x="${absX}" y="${absY - 4}">${escHTML(layout.node.label)}</text>`;
    svg += `<text class="edge-label" x="${absX}" y="${absY + 10}">${nodeCount} (${nodePct}%)</text>`;
    svg += `</g>`;
  } else {
    svg += `<g class="tree-node">`;
    svg += `<rect x="${absX - NODE_W / 2}" y="${absY - NODE_H / 2}" width="${NODE_W}" height="${NODE_H}" fill="#1e3a5f" stroke="#3b82f6"/>`;
    svg += `<text x="${absX}" y="${absY - 6}">${escHTML(layout.node.attribute)}</text>`;
    svg += `<text class="edge-label" x="${absX}" y="${absY + 10}">${nodeCount} (${nodePct}%)</text>`;
    svg += `</g>`;
  }

  for (const c of layout.children) {
    svg += renderNodes(c, offX, offY, absX, totalCount);
  }
  return svg;
}

function escHTML(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// ---- Init ----
columns = ['Attr 1', 'Attr 2', 'Target'];
rows = [['', '', ''], ['', '', '']];
renderTable();
</script>
</body>
</html>

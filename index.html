<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Information Gain Calculator & Decision Tree Builder</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg-deep: #050a0f;
    --bg-panel: #0a1118;
    --bg-card: #0d1620;
    --border-dim: #1a2a3a;
    --border-glow: #0ea5e9;
    --accent-blue: #0ea5e9;
    --accent-cyan: #22d3ee;
    --accent-red: #ef4444;
    --accent-gold: #f59e0b;
    --accent-arc: #38bdf8;
    --text-primary: #e0f2fe;
    --text-dim: #64748b;
    --text-muted: #475569;
    --glow-blue: 0 0 15px rgba(14, 165, 233, 0.3), 0 0 40px rgba(14, 165, 233, 0.1);
    --glow-red: 0 0 15px rgba(239, 68, 68, 0.3), 0 0 40px rgba(239, 68, 68, 0.1);
    --glow-gold: 0 0 15px rgba(245, 158, 11, 0.3);
  }

  body {
    font-family: 'Share Tech Mono', 'Courier New', monospace;
    background: var(--bg-deep);
    color: var(--text-primary);
    min-height: 100vh;
    line-height: 1.6;
    overflow-x: hidden;
  }

  /* Animated background grid */
  body::before {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background:
      linear-gradient(rgba(14, 165, 233, 0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(14, 165, 233, 0.03) 1px, transparent 1px);
    background-size: 60px 60px;
    pointer-events: none;
    z-index: 0;
  }

  /* Scan line overlay */
  body::after {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(14, 165, 233, 0.015) 2px,
      rgba(14, 165, 233, 0.015) 4px
    );
    pointer-events: none;
    z-index: 9999;
    animation: scanDrift 8s linear infinite;
  }

  @keyframes scanDrift {
    0% { transform: translateY(0); }
    100% { transform: translateY(4px); }
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }

  @keyframes glowPulse {
    0%, 100% { box-shadow: 0 0 8px rgba(14, 165, 233, 0.2), inset 0 0 8px rgba(14, 165, 233, 0.05); }
    50% { box-shadow: 0 0 20px rgba(14, 165, 233, 0.4), inset 0 0 15px rgba(14, 165, 233, 0.08); }
  }

  @keyframes borderGlow {
    0%, 100% { border-color: rgba(14, 165, 233, 0.25); }
    50% { border-color: rgba(14, 165, 233, 0.5); }
  }

  @keyframes slideIn {
    from { opacity: 0; transform: translateY(8px); }
    to { opacity: 1; transform: translateY(0); }
  }

  @keyframes arcReactorSpin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  @keyframes dataStream {
    0% { background-position: 0% 0%; }
    100% { background-position: 0% 100%; }
  }

  /* Header */
  header {
    position: relative;
    background: linear-gradient(180deg, #0a1118 0%, var(--bg-deep) 100%);
    border-bottom: 1px solid var(--border-dim);
    padding: 1.5rem 2rem 1.25rem;
    text-align: center;
    z-index: 1;
    overflow: hidden;
  }

  header::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--accent-blue), var(--accent-cyan), var(--accent-blue), transparent);
    animation: pulse 3s ease-in-out infinite;
  }

  header::after {
    content: '';
    position: absolute;
    bottom: 0; left: 50%;
    transform: translateX(-50%);
    width: 200px; height: 1px;
    background: linear-gradient(90deg, transparent, var(--accent-red) 30%, var(--accent-gold) 50%, var(--accent-red) 70%, transparent);
  }

  /* Arc reactor decoration */
  .arc-reactor {
    display: inline-block;
    width: 44px; height: 44px;
    border-radius: 50%;
    border: 2px solid var(--accent-blue);
    position: relative;
    margin-bottom: 0.5rem;
    box-shadow: var(--glow-blue);
    animation: glowPulse 3s ease-in-out infinite;
  }

  .arc-reactor::before {
    content: '';
    position: absolute;
    top: 50%; left: 50%;
    width: 16px; height: 16px;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    background: radial-gradient(circle, var(--accent-cyan), var(--accent-blue) 60%, transparent 70%);
    box-shadow: 0 0 20px var(--accent-cyan), 0 0 40px rgba(34, 211, 238, 0.3);
  }

  .arc-reactor::after {
    content: '';
    position: absolute;
    top: 3px; left: 3px; right: 3px; bottom: 3px;
    border-radius: 50%;
    border: 1px solid rgba(14, 165, 233, 0.4);
    border-top-color: var(--accent-cyan);
    animation: arcReactorSpin 4s linear infinite;
  }

  header h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 1.6rem;
    font-weight: 900;
    letter-spacing: 3px;
    text-transform: uppercase;
    background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue), #818cf8);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: none;
    filter: drop-shadow(0 0 12px rgba(14, 165, 233, 0.3));
  }

  header .subtitle {
    color: var(--text-dim);
    font-size: 0.78rem;
    margin-top: 0.3rem;
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  .status-bar {
    display: flex;
    justify-content: center;
    gap: 2rem;
    margin-top: 0.75rem;
    font-size: 0.7rem;
    color: var(--text-muted);
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  .status-bar .status-dot {
    display: inline-block;
    width: 6px; height: 6px;
    border-radius: 50%;
    margin-right: 6px;
    vertical-align: middle;
  }

  .status-dot.green { background: #22c55e; box-shadow: 0 0 8px #22c55e; }
  .status-dot.blue { background: var(--accent-blue); box-shadow: 0 0 8px var(--accent-blue); }
  .status-dot.gold { background: var(--accent-gold); box-shadow: 0 0 8px var(--accent-gold); animation: pulse 2s ease-in-out infinite; }

  /* Container */
  .container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 1.5rem;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    position: relative;
    z-index: 1;
  }

  .full-width { grid-column: 1 / -1; }

  /* Cards - HUD panels */
  .card {
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    border-radius: 4px;
    padding: 1.25rem;
    overflow: hidden;
    position: relative;
    animation: borderGlow 4s ease-in-out infinite;
  }

  .card::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 40px; height: 2px;
    background: var(--accent-blue);
    box-shadow: 0 0 10px var(--accent-blue);
  }

  .card::after {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 2px; height: 40px;
    background: var(--accent-blue);
    box-shadow: 0 0 10px var(--accent-blue);
  }

  .card h2 {
    font-family: 'Orbitron', sans-serif;
    font-size: 0.85rem;
    margin-bottom: 1rem;
    color: var(--accent-cyan);
    display: flex;
    align-items: center;
    gap: 0.6rem;
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  .card h2 .icon {
    width: 28px; height: 28px;
    border-radius: 4px;
    display: flex; align-items: center; justify-content: center;
    font-size: 0.75rem;
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    border: 1px solid;
  }

  .card h2 .divider-line {
    flex: 1;
    height: 1px;
    background: linear-gradient(90deg, var(--border-dim), transparent);
    margin-left: 0.5rem;
  }

  /* Buttons */
  .btn-row { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem; }

  button {
    padding: 0.5rem 1rem;
    border: 1px solid var(--border-dim);
    border-radius: 3px;
    background: rgba(14, 165, 233, 0.06);
    color: var(--text-primary);
    cursor: pointer;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.8rem;
    letter-spacing: 1px;
    text-transform: uppercase;
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
  }

  button::before {
    content: '';
    position: absolute;
    top: 0; left: -100%;
    width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(14, 165, 233, 0.1), transparent);
    transition: left 0.4s;
  }

  button:hover::before { left: 100%; }
  button:hover {
    background: rgba(14, 165, 233, 0.12);
    border-color: var(--accent-blue);
    box-shadow: 0 0 10px rgba(14, 165, 233, 0.15);
    color: var(--accent-cyan);
  }

  .btn-primary {
    background: linear-gradient(135deg, rgba(14, 165, 233, 0.2), rgba(99, 102, 241, 0.2));
    border: 1px solid var(--accent-blue);
    color: var(--accent-cyan);
    font-weight: 700;
    padding: 0.6rem 1.5rem;
    font-size: 0.85rem;
    box-shadow: 0 0 10px rgba(14, 165, 233, 0.15), inset 0 0 10px rgba(14, 165, 233, 0.05);
  }

  .btn-primary:hover {
    background: linear-gradient(135deg, rgba(14, 165, 233, 0.3), rgba(99, 102, 241, 0.3));
    box-shadow: 0 0 20px rgba(14, 165, 233, 0.3), inset 0 0 15px rgba(14, 165, 233, 0.08);
  }

  .btn-danger {
    border-color: rgba(239, 68, 68, 0.4);
    color: #f87171;
    background: rgba(239, 68, 68, 0.06);
  }

  .btn-danger:hover {
    background: rgba(239, 68, 68, 0.15);
    border-color: var(--accent-red);
    box-shadow: 0 0 10px rgba(239, 68, 68, 0.2);
  }

  /* Data Table */
  .table-wrap {
    overflow-x: auto;
    max-height: 400px;
    overflow-y: auto;
    border: 1px solid var(--border-dim);
    border-radius: 3px;
  }

  .table-wrap::-webkit-scrollbar { width: 6px; height: 6px; }
  .table-wrap::-webkit-scrollbar-track { background: var(--bg-deep); }
  .table-wrap::-webkit-scrollbar-thumb { background: var(--border-dim); border-radius: 3px; }
  .table-wrap::-webkit-scrollbar-thumb:hover { background: var(--accent-blue); }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.82rem;
  }

  th, td {
    padding: 0.5rem 0.75rem;
    border: 1px solid rgba(26, 42, 58, 0.6);
    text-align: left;
    white-space: nowrap;
  }

  th {
    background: var(--bg-deep);
    position: sticky;
    top: 0;
    z-index: 1;
    font-weight: 600;
    color: var(--accent-blue);
    font-family: 'Orbitron', sans-serif;
    font-size: 0.7rem;
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  th.target-col { color: var(--accent-gold); }

  td {
    background: var(--bg-card);
    transition: background 0.15s;
  }

  th input, td input {
    background: transparent;
    border: none;
    color: inherit;
    width: 100%;
    min-width: 60px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.82rem;
    outline: none;
    padding: 2px;
  }

  th input {
    font-family: 'Orbitron', sans-serif;
    font-weight: 600;
    font-size: 0.7rem;
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  th input::placeholder, td input::placeholder { color: var(--text-muted); }
  td input:focus { background: rgba(14, 165, 233, 0.05); border-radius: 2px; }
  tr:hover td { background: rgba(14, 165, 233, 0.06); }

  .row-num {
    color: var(--text-muted);
    font-size: 0.7rem;
    text-align: center;
    width: 30px;
    padding: 0.5rem 0.4rem;
    user-select: none;
    font-family: 'Orbitron', sans-serif;
  }

  .del-row-btn {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 0.75rem;
    padding: 2px 6px;
    border-radius: 3px;
    transition: all 0.15s;
  }

  .del-row-btn:hover {
    color: var(--accent-red);
    background: rgba(239, 68, 68, 0.1);
    box-shadow: 0 0 8px rgba(239, 68, 68, 0.15);
  }

  /* Results */
  .result-section { margin-bottom: 1.25rem; animation: slideIn 0.4s ease; }

  .result-section h3 {
    font-family: 'Orbitron', sans-serif;
    font-size: 0.7rem;
    color: var(--text-dim);
    margin-bottom: 0.5rem;
    border-bottom: 1px solid var(--border-dim);
    padding-bottom: 0.35rem;
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  .entropy-value {
    font-family: 'Orbitron', sans-serif;
    font-size: 2rem;
    font-weight: 900;
    color: var(--accent-cyan);
    text-shadow: 0 0 20px rgba(34, 211, 238, 0.4), 0 0 40px rgba(34, 211, 238, 0.15);
    letter-spacing: 2px;
  }

  .gain-bar-wrap { margin-bottom: 0.7rem; animation: slideIn 0.5s ease; }

  .gain-label {
    display: flex;
    justify-content: space-between;
    font-size: 0.82rem;
    margin-bottom: 0.25rem;
  }

  .gain-label .attr-name {
    font-weight: 600;
    color: var(--text-primary);
    letter-spacing: 1px;
  }

  .gain-label .attr-val {
    color: var(--accent-cyan);
    font-family: 'Orbitron', sans-serif;
    font-size: 0.75rem;
    font-weight: 700;
  }

  .gain-bar-bg {
    height: 24px;
    background: var(--bg-deep);
    border-radius: 3px;
    overflow: hidden;
    border: 1px solid var(--border-dim);
    position: relative;
  }

  .gain-bar-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.8s cubic-bezier(0.22, 1, 0.36, 1);
    min-width: 2px;
    position: relative;
    overflow: hidden;
  }

  .gain-bar-fill::after {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: repeating-linear-gradient(
      -45deg,
      transparent,
      transparent 4px,
      rgba(255,255,255,0.05) 4px,
      rgba(255,255,255,0.05) 8px
    );
  }

  /* Explanation */
  .math-steps {
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.78rem;
    color: var(--text-dim);
    background: var(--bg-deep);
    border: 1px solid var(--border-dim);
    border-radius: 3px;
    padding: 1rem;
    max-height: 500px;
    overflow-y: auto;
    line-height: 1.9;
    white-space: pre-wrap;
    position: relative;
  }

  .math-steps::-webkit-scrollbar { width: 6px; }
  .math-steps::-webkit-scrollbar-track { background: var(--bg-deep); }
  .math-steps::-webkit-scrollbar-thumb { background: var(--border-dim); border-radius: 3px; }

  .math-steps .highlight {
    color: var(--accent-cyan);
    font-weight: 700;
    text-shadow: 0 0 10px rgba(34, 211, 238, 0.3);
  }

  .math-steps .formula { color: #a78bfa; }

  .math-steps .section-title {
    color: var(--accent-gold);
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    font-size: 0.78rem;
    letter-spacing: 1px;
    text-shadow: 0 0 10px rgba(245, 158, 11, 0.3);
  }

  /* Tree */
  .tree-container {
    overflow: auto;
    background: var(--bg-deep);
    border: 1px solid var(--border-dim);
    border-radius: 3px;
    min-height: 300px;
    position: relative;
  }

  .tree-container::-webkit-scrollbar { width: 6px; height: 6px; }
  .tree-container::-webkit-scrollbar-track { background: var(--bg-deep); }
  .tree-container::-webkit-scrollbar-thumb { background: var(--border-dim); border-radius: 3px; }

  .tree-container svg { display: block; }

  .tree-node rect {
    rx: 4; ry: 4;
    stroke-width: 1.5;
  }

  .tree-node text {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    fill: var(--text-primary);
    text-anchor: middle;
    dominant-baseline: middle;
  }

  .tree-edge {
    stroke: rgba(14, 165, 233, 0.25);
    stroke-width: 1.5;
    fill: none;
  }

  .edge-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    fill: var(--text-dim);
    text-anchor: middle;
  }

  .no-data {
    text-align: center;
    color: var(--text-muted);
    padding: 3rem 1rem;
    font-size: 0.85rem;
    letter-spacing: 1px;
  }

  .no-data strong { color: var(--accent-blue); }

  .hint-text {
    color: var(--text-muted);
    font-size: 0.72rem;
    margin-top: 0.5rem;
    letter-spacing: 0.5px;
  }

  .hint-text strong { color: var(--accent-gold); text-shadow: 0 0 8px rgba(245, 158, 11, 0.2); }

  /* Floating particles container */
  .particles {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    z-index: 0;
    overflow: hidden;
  }

  .particle {
    position: absolute;
    width: 2px; height: 2px;
    background: var(--accent-blue);
    border-radius: 50%;
    opacity: 0;
    animation: floatParticle linear infinite;
  }

  @keyframes floatParticle {
    0% { opacity: 0; transform: translateY(100vh) scale(0); }
    10% { opacity: 0.6; }
    90% { opacity: 0.6; }
    100% { opacity: 0; transform: translateY(-10vh) scale(1); }
  }

  /* Theme toggle button */
  .theme-toggle {
    position: fixed;
    top: 1rem;
    right: 1rem;
    z-index: 10000;
    padding: 0.5rem 0.85rem;
    border-radius: 4px;
    cursor: pointer;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.7rem;
    letter-spacing: 1px;
    text-transform: uppercase;
    transition: all 0.3s;
    border: 1px solid var(--accent-blue);
    background: rgba(14, 165, 233, 0.1);
    color: var(--accent-cyan);
    box-shadow: 0 0 10px rgba(14, 165, 233, 0.15);
    backdrop-filter: blur(8px);
  }

  .theme-toggle:hover {
    background: rgba(14, 165, 233, 0.2);
    box-shadow: 0 0 20px rgba(14, 165, 233, 0.3);
  }

  .theme-toggle::before { display: none; }

  /* ============================
     CLEAN THEME
     ============================ */
  body.clean-theme {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: #0f172a;
    color: #e2e8f0;
  }

  body.clean-theme::before,
  body.clean-theme::after { display: none; }

  body.clean-theme .particles { display: none; }

  body.clean-theme .arc-reactor { display: none; }

  body.clean-theme header {
    background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
    border-bottom: 1px solid #334155;
  }

  body.clean-theme header::before,
  body.clean-theme header::after { display: none; }

  body.clean-theme header h1 {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 1.75rem;
    letter-spacing: 0;
    text-transform: none;
    background: linear-gradient(135deg, #38bdf8, #818cf8);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    filter: none;
  }

  body.clean-theme header .subtitle {
    font-size: 0.9rem;
    letter-spacing: 0;
    text-transform: none;
    color: #94a3b8;
  }

  body.clean-theme .status-bar { display: none; }

  body.clean-theme .card {
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 12px;
    animation: none;
  }

  body.clean-theme .card::before,
  body.clean-theme .card::after { display: none; }

  body.clean-theme .card h2 {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 1.1rem;
    color: #f1f5f9;
    letter-spacing: 0;
    text-transform: none;
  }

  body.clean-theme .card h2 .icon {
    border-radius: 6px;
    font-family: 'Segoe UI', system-ui, sans-serif;
    border: none;
  }

  body.clean-theme .card h2 .divider-line { display: none; }

  body.clean-theme button {
    font-family: 'Segoe UI', system-ui, sans-serif;
    border-radius: 8px;
    background: #334155;
    border-color: #475569;
    letter-spacing: 0;
    text-transform: none;
    font-size: 0.85rem;
  }

  body.clean-theme button::before { display: none; }
  body.clean-theme button:hover { background: #475569; border-color: #64748b; color: #e2e8f0; box-shadow: none; }

  body.clean-theme .btn-primary {
    background: linear-gradient(135deg, #3b82f6, #6366f1);
    border: none;
    color: #fff;
    font-size: 0.95rem;
    box-shadow: none;
  }

  body.clean-theme .btn-primary:hover { opacity: 0.9; background: linear-gradient(135deg, #3b82f6, #6366f1); box-shadow: none; }

  body.clean-theme .btn-danger { border-color: #ef4444; color: #f87171; background: #334155; }
  body.clean-theme .btn-danger:hover { background: #7f1d1d; box-shadow: none; }

  body.clean-theme th {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 0.85rem;
    color: inherit;
    letter-spacing: 0;
    text-transform: none;
    background: #0f172a;
    font-weight: 600;
  }

  body.clean-theme th.target-col { color: #f59e0b; }

  body.clean-theme th, body.clean-theme td {
    border-color: #334155;
  }

  body.clean-theme td { background: #1e293b; }
  body.clean-theme tr:hover td { background: #263348; }

  body.clean-theme th input, body.clean-theme td input {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 0.85rem;
    letter-spacing: 0;
    text-transform: none;
  }

  body.clean-theme td input:focus { background: #0f172a; }

  body.clean-theme .table-wrap { border: none; border-radius: 0; }

  body.clean-theme .row-num { font-family: 'Segoe UI', system-ui, sans-serif; font-size: 0.75rem; }

  body.clean-theme .result-section h3 {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 0.95rem;
    color: #94a3b8;
    letter-spacing: 0;
    text-transform: none;
    border-color: #334155;
  }

  body.clean-theme .entropy-value {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 1.5rem;
    color: #38bdf8;
    text-shadow: none;
    letter-spacing: 0;
  }

  body.clean-theme .gain-label .attr-val {
    font-family: 'Courier New', monospace;
    color: #38bdf8;
    font-size: 0.85rem;
  }

  body.clean-theme .gain-bar-bg {
    background: #0f172a;
    border-radius: 6px;
    border: none;
  }

  body.clean-theme .gain-bar-fill { border-radius: 6px; }
  body.clean-theme .gain-bar-fill::after { display: none; }

  body.clean-theme .math-steps {
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    color: #94a3b8;
    background: #0f172a;
    border: none;
    border-radius: 8px;
  }

  body.clean-theme .math-steps .highlight { color: #38bdf8; text-shadow: none; }
  body.clean-theme .math-steps .section-title {
    font-family: 'Courier New', monospace;
    color: #f59e0b;
    letter-spacing: 0;
    text-shadow: none;
  }

  body.clean-theme .tree-container {
    background: #0f172a;
    border: none;
    border-radius: 8px;
  }

  body.clean-theme .tree-edge { stroke: #475569; stroke-width: 2; }

  body.clean-theme .no-data { color: #475569; letter-spacing: 0; }
  body.clean-theme .no-data strong { color: inherit; }

  body.clean-theme .hint-text { color: #64748b; letter-spacing: 0; }

  body.clean-theme .theme-toggle {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: #334155;
    border-color: #475569;
    color: #e2e8f0;
    box-shadow: none;
    letter-spacing: 0;
    text-transform: none;
    border-radius: 8px;
    font-size: 0.8rem;
  }

  body.clean-theme .theme-toggle:hover { background: #475569; box-shadow: none; }

  @media (max-width: 900px) {
    .container { grid-template-columns: 1fr; }
    header h1 { font-size: 1.1rem; letter-spacing: 1px; }
    body.clean-theme header h1 { letter-spacing: 0; font-size: 1.4rem; }
  }
</style>
</head>
<body>

<button class="theme-toggle" id="themeToggle" onclick="toggleTheme()">Clean Mode</button>

<!-- Floating particles -->
<div class="particles" id="particles"></div>

<header>
  <div class="arc-reactor"></div>
  <h1>Information Gain Calculator</h1>
  <p class="subtitle">Decision Tree Builder // Entropy Analysis System</p>
  <div class="status-bar">
    <span><span class="status-dot green"></span>System Online</span>
    <span><span class="status-dot blue"></span>ID3 Engine Ready</span>
    <span><span class="status-dot gold"></span>Awaiting Data</span>
  </div>
</header>
<!-- TAG: IC | XC ; NI | KA -->

<div class="container">

  <!-- Dataset Input -->
  <div class="card full-width">
    <h2>
      <span class="icon" style="background:rgba(14,165,233,0.1);color:var(--accent-blue);border-color:rgba(14,165,233,0.3);">01</span>
      Dataset Input
      <span class="divider-line"></span>
    </h2>
    <div class="btn-row">
      <button onclick="loadSampleData()" class="btn-primary">Load Sample Data</button>
      <button onclick="addColumn()">+ Column</button>
      <button onclick="addRow()">+ Row</button>
      <button onclick="removeLastColumn()" class="btn-danger">- Column</button>
      <button onclick="clearData()" class="btn-danger">Clear All</button>
      <span style="flex:1"></span>
      <button onclick="calculate()" class="btn-primary" id="calcBtn">Execute Analysis</button>
    </div>
    <div class="table-wrap">
      <table id="dataTable"><thead><tr></tr></thead><tbody></tbody></table>
    </div>
    <p class="hint-text">
      The <strong>last column</strong> is the target/label. Edit headers to name attributes.
      Paste from Excel supported.
    </p>
  </div>

  <!-- Information Gain Results -->
  <div class="card">
    <h2>
      <span class="icon" style="background:rgba(34,211,238,0.1);color:var(--accent-cyan);border-color:rgba(34,211,238,0.3);">02</span>
      Information Gain
      <span class="divider-line"></span>
    </h2>
    <div id="resultsPanel">
      <div class="no-data">Enter data and <strong>execute analysis</strong> to see results.</div>
    </div>
  </div>

  <!-- Step-by-step Explanation -->
  <div class="card">
    <h2>
      <span class="icon" style="background:rgba(167,139,250,0.1);color:#a78bfa;border-color:rgba(167,139,250,0.3);">03</span>
      Computation Log
      <span class="divider-line"></span>
    </h2>
    <div id="explanationPanel">
      <div class="no-data">Computation trace will render here.</div>
    </div>
  </div>

  <!-- Decision Tree -->
  <div class="card full-width">
    <h2>
      <span class="icon" style="background:rgba(245,158,11,0.1);color:var(--accent-gold);border-color:rgba(245,158,11,0.3);">04</span>
      Decision Tree Visualization
      <span class="divider-line"></span>
    </h2>
    <div class="tree-container" id="treeContainer">
      <div class="no-data">Decision tree will materialize after analysis.</div>
    </div>
  </div>

</div>

<script>
// ---- Particles ----
(function initParticles() {
  const container = document.getElementById('particles');
  for (let i = 0; i < 30; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
    p.style.left = Math.random() * 100 + '%';
    p.style.animationDuration = (8 + Math.random() * 12) + 's';
    p.style.animationDelay = (Math.random() * 15) + 's';
    p.style.width = p.style.height = (1 + Math.random() * 2) + 'px';
    if (Math.random() > 0.7) p.style.background = '#22d3ee';
    if (Math.random() > 0.9) p.style.background = '#f59e0b';
    container.appendChild(p);
  }
})();

// ---- State ----
let columns = [];
let rows = [];

// ---- Table Rendering ----
function renderTable() {
  const thead = document.querySelector('#dataTable thead tr');
  const tbody = document.querySelector('#dataTable tbody');
  thead.innerHTML = '';
  tbody.innerHTML = '';

  const thNum = document.createElement('th');
  thNum.className = 'row-num';
  thNum.textContent = '#';
  thead.appendChild(thNum);

  columns.forEach((col, ci) => {
    const th = document.createElement('th');
    if (ci === columns.length - 1) th.className = 'target-col';
    const inp = document.createElement('input');
    inp.value = col;
    inp.placeholder = ci === columns.length - 1 ? 'Target' : `Attr ${ci + 1}`;
    inp.addEventListener('input', () => { columns[ci] = inp.value; });
    th.appendChild(inp);
    thead.appendChild(th);
  });

  const thDel = document.createElement('th');
  thDel.style.width = '30px';
  thead.appendChild(thDel);

  rows.forEach((row, ri) => {
    const tr = document.createElement('tr');
    const tdNum = document.createElement('td');
    tdNum.className = 'row-num';
    tdNum.textContent = ri + 1;
    tr.appendChild(tdNum);

    columns.forEach((_, ci) => {
      const td = document.createElement('td');
      const inp = document.createElement('input');
      inp.value = row[ci] || '';
      inp.addEventListener('input', () => { rows[ri][ci] = inp.value.trim(); });
      inp.addEventListener('paste', (e) => handleCellPaste(e, ri, ci));
      td.appendChild(inp);
      tr.appendChild(td);
    });

    const tdDel = document.createElement('td');
    tdDel.style.padding = '0';
    const delBtn = document.createElement('button');
    delBtn.className = 'del-row-btn';
    delBtn.textContent = '\u00d7';
    delBtn.title = 'Delete row';
    delBtn.addEventListener('click', () => { rows.splice(ri, 1); renderTable(); });
    tdDel.appendChild(delBtn);
    tr.appendChild(tdDel);

    tbody.appendChild(tr);
  });
}

function parsePastedMatrix(text) {
  const normalized = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n+$/g, '');
  if (!normalized) return [];
  return normalized
    .split('\n')
    .map(line => line.split('\t').map(cell => cell.trim()));
}

function ensureShape(requiredRows, requiredCols) {
  if (requiredCols > columns.length) {
    while (columns.length < requiredCols) {
      const insertAt = Math.max(columns.length - 1, 0);
      const attrName = `Attr ${insertAt + 1}`;
      columns.splice(insertAt, 0, attrName);
      rows.forEach(r => r.splice(insertAt, 0, ''));
    }
  }
  rows.forEach(r => { while (r.length < columns.length) r.push(''); });
  while (rows.length < requiredRows) {
    rows.push(new Array(columns.length).fill(''));
  }
}

function handleCellPaste(event, startRow, startCol) {
  const raw = event.clipboardData && event.clipboardData.getData('text');
  if (!raw) return;
  if (!raw.includes('\t') && !raw.includes('\n') && !raw.includes('\r')) return;
  event.preventDefault();
  const matrix = parsePastedMatrix(raw);
  if (matrix.length === 0) return;
  const maxCols = Math.max(...matrix.map(r => r.length), 0);
  if (maxCols === 0) return;
  ensureShape(startRow + matrix.length, startCol + maxCols);
  matrix.forEach((r, ri) => {
    r.forEach((val, ci) => { rows[startRow + ri][startCol + ci] = val; });
  });
  renderTable();
}

function addColumn() { columns.push(''); rows.forEach(r => r.push('')); renderTable(); }
function addRow() { rows.push(new Array(columns.length).fill('')); renderTable(); }
function removeLastColumn() { if (columns.length <= 1) return; columns.pop(); rows.forEach(r => r.pop()); renderTable(); }

function clearData() {
  columns = ['Attr 1', 'Target'];
  rows = [['', '']];
  renderTable();
  document.getElementById('resultsPanel').innerHTML = '<div class="no-data">Enter data and <strong>execute analysis</strong> to see results.</div>';
  document.getElementById('explanationPanel').innerHTML = '<div class="no-data">Computation trace will render here.</div>';
  document.getElementById('treeContainer').innerHTML = '<div class="no-data">Decision tree will materialize after analysis.</div>';
}

function loadSampleData() {
  columns = ['Outlook', 'Temperature', 'Humidity', 'Wind', 'Play Tennis'];
  rows = [
    ['Sunny','Hot','High','Weak','No'],
    ['Sunny','Hot','High','Strong','No'],
    ['Overcast','Hot','High','Weak','Yes'],
    ['Rain','Mild','High','Weak','Yes'],
    ['Rain','Cool','Normal','Weak','Yes'],
    ['Rain','Cool','Normal','Strong','No'],
    ['Overcast','Cool','Normal','Strong','Yes'],
    ['Sunny','Mild','High','Weak','No'],
    ['Sunny','Cool','Normal','Weak','Yes'],
    ['Rain','Mild','Normal','Weak','Yes'],
    ['Sunny','Mild','Normal','Strong','Yes'],
    ['Overcast','Mild','High','Strong','Yes'],
    ['Overcast','Hot','Normal','Weak','Yes'],
    ['Rain','Mild','High','Strong','No'],
  ];
  renderTable();
}

// ---- Math helpers ----
function log2(x) { return x === 0 ? 0 : Math.log2(x); }

function entropy(counts) {
  const total = counts.reduce((a, b) => a + b, 0);
  if (total === 0) return 0;
  let h = 0;
  for (const c of counts) { const p = c / total; h -= p * log2(p); }
  return h;
}

function countValues(arr) {
  const map = {};
  arr.forEach(v => { map[v] = (map[v] || 0) + 1; });
  return map;
}

// ---- Calculation ----
function calculate() {
  const nCols = columns.length;
  if (nCols < 2) { alert('Need at least one attribute and one target column.'); return; }

  const validRows = rows.filter(r => r.length === nCols && r.every(v => v !== ''));
  if (validRows.length === 0) { alert('No complete rows found. Fill in the table first.'); return; }

  const targetIdx = nCols - 1;
  const targetValues = validRows.map(r => r[targetIdx]);
  const targetCounts = countValues(targetValues);
  const totalEntropy = entropy(Object.values(targetCounts));

  const attrIndices = [];
  for (let i = 0; i < targetIdx; i++) attrIndices.push(i);

  const gains = [];
  let explanation = '';

  explanation += `<span class="section-title">// OVERALL ENTROPY (${columns[targetIdx]})</span>\n`;
  explanation += `Total samples: ${validRows.length}\n`;
  for (const [val, cnt] of Object.entries(targetCounts)) {
    explanation += `  ${val}: ${cnt} (${(cnt / validRows.length * 100).toFixed(1)}%)\n`;
  }
  explanation += `\n<span class="formula">H(S) = `;
  const parts = [];
  for (const [val, cnt] of Object.entries(targetCounts)) {
    parts.push(`-(${cnt}/${validRows.length}) * log2(${cnt}/${validRows.length})`);
  }
  explanation += parts.join('\n       ');
  explanation += `</span>\n<span class="highlight">H(S) = ${totalEntropy.toFixed(4)}</span>\n\n`;

  for (const ai of attrIndices) {
    const attrName = columns[ai] || `Attr ${ai + 1}`;
    const attrValues = validRows.map(r => r[ai]);
    const uniqueVals = [...new Set(attrValues)];

    explanation += `<span class="section-title">// ATTRIBUTE: ${attrName}</span>\n`;

    let condEntropy = 0;
    const subsets = {};

    for (const val of uniqueVals) {
      const subset = validRows.filter(r => r[ai] === val);
      const subTargetCounts = countValues(subset.map(r => r[targetIdx]));
      const subH = entropy(Object.values(subTargetCounts));
      const weight = subset.length / validRows.length;
      condEntropy += weight * subH;
      subsets[val] = { count: subset.length, targetCounts: subTargetCounts, entropy: subH, weight };

      explanation += `  ${attrName} = "${val}" (${subset.length}/${validRows.length}):\n`;
      for (const [tv, tc] of Object.entries(subTargetCounts)) {
        explanation += `    ${tv}: ${tc}\n`;
      }
      explanation += `    <span class="formula">H = ${subH.toFixed(4)}</span>\n`;
    }

    explanation += `\n  <span class="formula">H(S|${attrName}) = `;
    const cParts = uniqueVals.map(v => `(${subsets[v].count}/${validRows.length}) * ${subsets[v].entropy.toFixed(4)}`);
    explanation += cParts.join(' + ');
    explanation += ` = ${condEntropy.toFixed(4)}</span>\n`;

    const gain = totalEntropy - condEntropy;
    explanation += `  <span class="highlight">Gain(${attrName}) = ${totalEntropy.toFixed(4)} - ${condEntropy.toFixed(4)} = ${gain.toFixed(4)}</span>\n\n`;

    gains.push({ name: attrName, index: ai, gain, condEntropy });
  }

  gains.sort((a, b) => b.gain - a.gain);

  const maxGain = Math.max(...gains.map(g => g.gain), 0.001);
  const colors = ['#0ea5e9', '#22d3ee', '#818cf8', '#a78bfa', '#f59e0b', '#ef4444', '#22c55e'];

  let html = `<div class="result-section"><h3>Dataset Entropy</h3><div class="entropy-value">${totalEntropy.toFixed(4)}</div><p style="color:var(--text-muted);font-size:0.75rem;margin-top:0.25rem;">${validRows.length} samples // ${Object.keys(targetCounts).length} classes</p></div>`;
  html += `<div class="result-section"><h3>Gain by Attribute</h3>`;

  gains.forEach((g, i) => {
    const pct = (g.gain / maxGain) * 100;
    const color = colors[i % colors.length];
    html += `<div class="gain-bar-wrap">
      <div class="gain-label"><span class="attr-name">${g.name}</span><span class="attr-val">${g.gain.toFixed(4)}</span></div>
      <div class="gain-bar-bg"><div class="gain-bar-fill" style="width:${pct}%;background:linear-gradient(90deg, ${color}, ${color}88);box-shadow:0 0 12px ${color}44;"></div></div>
    </div>`;
  });

  html += `</div>`;
  document.getElementById('resultsPanel').innerHTML = html;
  document.getElementById('explanationPanel').innerHTML = `<div class="math-steps">${explanation}</div>`;

  const tree = buildID3(validRows, attrIndices.slice(), targetIdx);
  renderTree(tree);

  // Update status indicator
  const dots = document.querySelectorAll('.status-dot.gold');
  dots.forEach(d => { d.className = 'status-dot green'; });
  const statusTexts = document.querySelectorAll('.status-bar span');
  if (statusTexts[2]) statusTexts[2].innerHTML = '<span class="status-dot green"></span>Analysis Complete';
}

// ---- ID3 ----
function buildID3(data, availableAttrs, targetIdx) {
  const targets = data.map(r => r[targetIdx]);
  const unique = [...new Set(targets)];
  const targetName = columns[targetIdx] || 'Target';
  const tc = countValues(targets);
  const majority = Object.entries(tc).sort((a, b) => b[1] - a[1])[0][0];

  if (availableAttrs.length === 0) {
    return { type: 'leaf', label: majority, count: data.length, targetName, classCounts: tc };
  }

  const totalH = entropy(Object.values(countValues(targets)));
  let bestAttr = availableAttrs[0];
  let bestGain = -1;

  for (const ai of availableAttrs) {
    const vals = [...new Set(data.map(r => r[ai]))];
    let condH = 0;
    for (const v of vals) {
      const subset = data.filter(r => r[ai] === v);
      condH += (subset.length / data.length) * entropy(Object.values(countValues(subset.map(r => r[targetIdx]))));
    }
    const g = totalH - condH;
    if (g > bestGain) { bestGain = g; bestAttr = ai; }
  }

  const node = {
    type: 'node',
    attribute: columns[bestAttr] || `Attr ${bestAttr + 1}`,
    attrIndex: bestAttr,
    gain: bestGain,
    children: [],
    count: data.length
  };

  const vals = [...new Set(data.map(r => r[bestAttr]))];
  const remaining = availableAttrs.filter(a => a !== bestAttr);

  const parentAttrName = node.attribute;
  for (const v of vals) {
    const subset = data.filter(r => r[bestAttr] === v);
    const edgeRatio = subset.length / data.length;
    if (subset.length === 0) {
      const majority = Object.entries(tc).sort((a, b) => b[1] - a[1])[0][0];
      node.children.push({ edgeLabel: v, edgeCount: 0, edgeRatio, child: { type: 'leaf', label: majority, count: 0, targetName, classCounts: {}, parentAttr: parentAttrName, parentValue: v } });
    } else {
      const child = buildID3(subset, remaining, targetIdx);
      if (child.type === 'leaf') {
        child.parentAttr = parentAttrName;
        child.parentValue = v;
      }
      node.children.push({ edgeLabel: v, edgeCount: subset.length, edgeRatio, child });
    }
  }

  return node;
}

// ---- Tree Rendering (SVG) ----
function renderTree(tree) {
  const container = document.getElementById('treeContainer');
  const layout = layoutTree(tree, 0, 0);
  const { minX, maxX, minY, maxY } = getBounds(layout);
  const totalCount = tree.count || 1;

  const padding = 40;
  const width = (maxX - minX) + padding * 2;
  const height = (maxY - minY) + padding * 2;
  const offsetX = -minX + padding;
  const offsetY = -minY + padding;

  let svg = `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">`;
  svg += `<defs>
    <filter id="glow"><feGaussianBlur stdDeviation="3" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
    <filter id="glowGold"><feGaussianBlur stdDeviation="2" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
  </defs>`;
  svg += renderEdges(layout, offsetX, offsetY);
  svg += renderNodes(layout, offsetX, offsetY, undefined, totalCount);
  svg += `</svg>`;
  container.innerHTML = svg;
}

const NODE_W = 140;
const NODE_H = 52;
const LEAF_W = 150;
const LEAF_H = 76;
const H_GAP = 44;
const V_GAP = 100;

function layoutTree(node, depth, index) {
  if (node.type === 'leaf') {
    return { node, x: 0, y: depth * (NODE_H + V_GAP), width: LEAF_W, children: [] };
  }

  const childLayouts = node.children.map((c, i) => {
    const cl = layoutTree(c.child, depth + 1, i);
    cl.edgeLabel = c.edgeLabel;
    cl.edgeRatio = c.edgeRatio;
    return cl;
  });

  const totalChildWidth = childLayouts.reduce((s, c) => s + c.width, 0) + H_GAP * (childLayouts.length - 1);
  const nodeWidth = Math.max(NODE_W, totalChildWidth);

  let cx = -totalChildWidth / 2;
  for (const cl of childLayouts) {
    cl.x = cx + cl.width / 2;
    cx += cl.width + H_GAP;
  }

  return { node, x: 0, y: depth * (NODE_H + V_GAP), width: nodeWidth, children: childLayouts };
}

function getBounds(layout) {
  const selfW = layout.node.type === 'leaf' ? LEAF_W : NODE_W;
  const selfH = layout.node.type === 'leaf' ? LEAF_H : NODE_H;
  let minX = layout.x - selfW / 2, maxX = layout.x + selfW / 2;
  let minY = layout.y - selfH / 2, maxY = layout.y + selfH / 2;
  for (const c of layout.children) {
    const b = getBoundsOffset(c, layout.x);
    minX = Math.min(minX, b.minX); maxX = Math.max(maxX, b.maxX);
    minY = Math.min(minY, b.minY); maxY = Math.max(maxY, b.maxY);
  }
  return { minX, maxX, minY, maxY };
}

function getBoundsOffset(layout, parentX) {
  const absX = parentX + layout.x;
  const w = layout.node.type === 'leaf' ? LEAF_W : NODE_W;
  const h = layout.node.type === 'leaf' ? LEAF_H : NODE_H;
  let minX = absX - w / 2, maxX = absX + w / 2;
  let minY = layout.y - h / 2, maxY = layout.y + h / 2;
  for (const c of layout.children) {
    const b = getBoundsOffset(c, absX);
    minX = Math.min(minX, b.minX); maxX = Math.max(maxX, b.maxX);
    minY = Math.min(minY, b.minY); maxY = Math.max(maxY, b.maxY);
  }
  return { minX, maxX, minY, maxY };
}

function renderEdges(layout, offX, offY, parentAbsX) {
  let svg = '';
  const absX = (parentAbsX !== undefined ? parentAbsX : 0) + layout.x + offX;
  const absY = layout.y + offY;

  const siblings = layout.children.length;
  for (let i = 0; i < siblings; i++) {
    const c = layout.children[i];
    const cAbsX = absX + c.x;
    const cAbsY = c.y + offY;
    const midY = (absY + NODE_H + cAbsY) / 2;
    svg += `<path class="tree-edge" d="M${absX},${absY + NODE_H / 2} C${absX},${midY} ${cAbsX},${midY} ${cAbsX},${cAbsY - (c.node.type === 'leaf' ? LEAF_H : NODE_H) / 2}"/>`;
    const childTop = cAbsY - (c.node.type === 'leaf' ? LEAF_H : NODE_H) / 2;
    const lx = absX + (cAbsX - absX) * 0.7;
    const stagger = (i - (siblings - 1) / 2) * 10;
    const ly = childTop - 14 + stagger;
    const edgePct = ((c.edgeRatio || 0) * 100).toFixed(1);
    const edgeText = `${c.edgeLabel} (${edgePct}%)`;
    const boxW = Math.max(58, Math.min(140, edgeText.length * 6.1 + 14));
    svg += `<rect x="${lx - boxW / 2}" y="${ly - 10}" width="${boxW}" height="20" rx="3" fill="#0a1118" stroke="#1a2a3a" stroke-width="1"/>`;
    svg += `<text class="edge-label" x="${lx}" y="${ly + 3}">${escHTML(edgeText)}</text>`;
    svg += renderEdges(c, offX, offY, absX);
  }
  return svg;
}

function renderNodes(layout, offX, offY, parentAbsX, totalCount) {
  let svg = '';
  const absX = (parentAbsX !== undefined ? parentAbsX : 0) + layout.x + offX;
  const absY = layout.y + offY;
  const nodeCount = layout.node.count || 0;
  const nodePct = totalCount > 0 ? ((nodeCount / totalCount) * 100).toFixed(1) : '0.0';

  if (layout.node.type === 'leaf') {
    const tName = layout.node.targetName || 'Target';
    const classCounts = layout.node.classCounts || {};
    const classStr = Object.entries(classCounts).map(([k,v]) => `${k}:${v}`).join(' | ');
    const pAttr = layout.node.parentAttr;
    const pVal = layout.node.parentValue;
    const condLine = pAttr ? `${pAttr} = ${pVal}` : '';
    const hasCondition = condLine.length > 0;
    const boxH = hasCondition ? LEAF_H + 14 : LEAF_H;
    const boxW = Math.max(LEAF_W, (condLine.length * 6.5) + 20);
    svg += `<g class="tree-node">`;
    svg += `<rect x="${absX - boxW / 2}" y="${absY - boxH / 2}" width="${boxW}" height="${boxH}" fill="#0a1a10" stroke="#22c55e" filter="url(#glowGold)" stroke-opacity="0.6"/>`;
    if (hasCondition) {
      svg += `<text x="${absX}" y="${absY - 20}" style="fill:#0ea5e9;font-size:9px;font-weight:bold;">${escHTML(condLine)}</text>`;
      svg += `<text x="${absX}" y="${absY - 6}" style="fill:#64748b;font-size:8px;">${escHTML(tName)}</text>`;
      svg += `<text x="${absX}" y="${absY + 10}" style="fill:#22c55e;font-weight:bold;font-size:13px;">${escHTML(layout.node.label)}</text>`;
      svg += `<text class="edge-label" x="${absX}" y="${absY + 26}" style="font-size:8px;">${classStr ? escHTML(classStr) : nodeCount + ' (' + nodePct + '%)'}</text>`;
    } else {
      svg += `<text x="${absX}" y="${absY - 16}" style="fill:#64748b;font-size:9px;">${escHTML(tName)}</text>`;
      svg += `<text x="${absX}" y="${absY}" style="fill:#22c55e;font-weight:bold;font-size:13px;">${escHTML(layout.node.label)}</text>`;
      svg += `<text class="edge-label" x="${absX}" y="${absY + 16}" style="font-size:8px;">${classStr ? escHTML(classStr) : nodeCount + ' (' + nodePct + '%)'}</text>`;
    }
    svg += `</g>`;
  } else {
    svg += `<g class="tree-node">`;
    svg += `<rect x="${absX - NODE_W / 2}" y="${absY - NODE_H / 2}" width="${NODE_W}" height="${NODE_H}" fill="#0a1520" stroke="#0ea5e9" filter="url(#glow)" stroke-opacity="0.5"/>`;
    svg += `<text x="${absX}" y="${absY - 6}" style="fill:#22d3ee;font-weight:bold;">${escHTML(layout.node.attribute)}</text>`;
    svg += `<text class="edge-label" x="${absX}" y="${absY + 12}" style="font-size:9px;">${nodeCount} (${nodePct}%)</text>`;
    svg += `</g>`;
  }

  for (const c of layout.children) {
    svg += renderNodes(c, offX, offY, absX, totalCount);
  }
  return svg;
}

function escHTML(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// ---- Theme Toggle ----
function toggleTheme() {
  const body = document.body;
  const btn = document.getElementById('themeToggle');
  body.classList.toggle('clean-theme');
  const isClean = body.classList.contains('clean-theme');
  btn.textContent = isClean ? 'HUD Mode' : 'Clean Mode';
  localStorage.setItem('theme', isClean ? 'clean' : 'hud');
}

(function restoreTheme() {
  if (localStorage.getItem('theme') === 'clean') {
    document.body.classList.add('clean-theme');
    document.getElementById('themeToggle').textContent = 'HUD Mode';
  }
})();

// ---- Init ----
columns = ['Attr 1', 'Attr 2', 'Target'];
rows = [['', '', ''], ['', '', '']];
renderTable();
</script>
</body>
</html>
